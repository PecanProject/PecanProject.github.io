"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9842],{4832:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"type":"mdx","permalink":"/pr-144/gsoc_ideas","source":"@site/src/pages/gsoc_ideas.mdx","title":"GSoC 2026 - PEcAn Project Ideas","description":"background}","frontMatter":{"title":"GSoC 2026 - PEcAn Project Ideas"},"unlisted":false}');var t=i(4848),r=i(8453);const o={title:"GSoC 2026 - PEcAn Project Ideas"},l="GSoC - PEcAn Project Ideas{#background}",a={},c=[{value:"Project Ideas",id:"ideas",level:2},{value:"1. Refactor and Parallelize Input Processing Pipelines",id:"input",level:3},{value:"2. Benchmarking and Validation Framework",id:"validation",level:3},{value:"3. Increase PEcAn modularity",id:"module",level:3},{value:"4. Standardizing Model Couplers Across Models",id:"couplertools",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"background",children:"GSoC - PEcAn Project Ideas"})}),"\n",(0,t.jsxs)(n.p,{children:["PEcAn is an open-source ecosystem modeling framework integrating data, models, and uncertainty quantification. Below is a list of potential ideas where contributors can help improve and expand PEcAn. To get started contributing to PEcAn, check out ",(0,t.jsx)(n.a,{href:"https://github.com/PecanProject/pecan/discussions/3469",children:"this guide"}),". Come find us on Slack to discuss. If you have questions or would like to propose your own idea, contact @kooper in or join our ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://pecanproject.slack.com/archives/C0853U6GF71",children:"#gsoc"})})," channel in Slack!"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"ideas",children:"Project Ideas"}),"\n",(0,t.jsx)(n.p,{children:"Below is a list of project ideas. Feel free to contact the listed mentors on Slack to discuss further or contact @kooper with new ideas and he can help connect you with mentors."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#input",children:"Refactor and Parallelize Input Processing Pipelines"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#validation",children:"Benchmarking and Validation Framework"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#module",children:"Increase PEcAn modularity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#couplertools",children:"Standardizing Model Couplers Across Models"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"input",children:"1. Refactor and Parallelize Input Processing Pipelines"}),"\n",(0,t.jsxs)(n.p,{children:["Input-processing code in PEcAn (e.g., meteorological preparation) is currently centered around monolithic orchestration functions such as ",(0,t.jsx)(n.code,{children:"do.conversions"})," and ",(0,t.jsx)(n.code,{children:"met.process"}),". These functions mix low-level data transformations with sequential control flow, implicit dependencies, and caching behavior, making them difficult to test, debug, scale, or parallelize across sites and ensemble members."]}),"\n",(0,t.jsxs)(n.p,{children:["This project will deprecate ",(0,t.jsx)(n.code,{children:"do.conversions"})," as currently implemented and replace it with input preprocessing workflows that are explicitly structured around data dependencies and are naturally parallelizable across data streams, sites, and ensemble members. The work will refactor or deprecate ",(0,t.jsx)(n.code,{children:"met.process"})," to remove monolithic orchestration and reduce or eliminate opaque caching, while retaining and strengthening existing low-level transformation functions."]}),"\n",(0,t.jsxs)(n.p,{children:["As part of the refactor, orchestration logic should be rebuilt to make inputs, outputs, and dependencies explicit. A workflow tool such as ",(0,t.jsx)(n.code,{children:"targets"})," may be used to help define and validate the dependency graph and caching behavior, but must not become a required or exclusive execution path for PEcAn."]}),"\n",(0,t.jsx)(n.p,{children:"This refactoring should also reduce or eliminate implicit dependencies on the global settings object (see Project 3), enabling clearer APIs and improved testability."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Expected outcomes:"})}),"\n",(0,t.jsx)(n.p,{children:"A successful project would complete the following tasks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Deprecation plan for do.conversions, with a replacement that provides a modular suite of preprocessing tools that"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"explicitly defines inputs and outputs, and"}),"\n",(0,t.jsx)(n.li,{children:"supports parallel execution across products, sites, and ensemble members.\nKey here is a high-level plan for development that will continue beyond what is accomplished this summer."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Refactor and/or deprecation plan for met.process that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"removes monolithic orchestration and hidden control flow,"}),"\n",(0,t.jsx)(n.li,{children:"reduces or eliminates over-engineered caching,"}),"\n",(0,t.jsx)(n.li,{children:"retains and documents low-level transformation functions."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Demonstration of parallel execution on a multi-site or multi-ensemble example."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Basic correctness and performance benchmarks, including unit and integration tests and validation of PEcAn-standard inputs (formats and units)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Updated developer documentation covering:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"the new input-processing architecture,"}),"\n",(0,t.jsx)(n.li,{children:"how to add a new preprocessing step,"}),"\n",(0,t.jsx)(n.li,{children:"migration guidance from legacy entry points."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Prerequisites:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Required: R (existing workflow and prototype is in R)"}),"\n",(0,t.jsx)(n.li,{children:"Helpful: familiarity with parallel computing, workflow refactoring"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Contact person:"})}),"\n",(0,t.jsx)(n.p,{children:"David LeBauer (@dlebauer), @Henry Priest"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Duration:"})}),"\n",(0,t.jsx)(n.p,{children:"Large (350 hr)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Difficulty:"})}),"\n",(0,t.jsx)(n.p,{children:"High"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"validation",children:"2. Benchmarking and Validation Framework"}),"\n",(0,t.jsx)(n.p,{children:'A key task in any modeling workflow is the validation of model outputs against held out observations. When a validation dataset is used repeatedly and agreed upon by a broad community to have particular value in assessing model performance it often gets elevated to the status of a persistent "benchmark" dataset. In PEcAn, there is a need to replace our earlier benchmarking module, whose design was never fully implemented, with a simpler framework. In designing this framework we\'d encourage participants to build upon the existing low-level infrastructure in the existing benchmarking module for model-data alignment tools and comparison metrics like RMSE, MAE, and R2. Work should also build upon and generalize existing examples of "one off" validation scripts (e.g., CARB cropland validations, North American data assimilation validations).'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Expected outcomes:"})}),"\n",(0,t.jsx)(n.p,{children:"A successful project would complete the following tasks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A high-level design and plan for development that will continue beyond what is accomplished this summer"}),"\n",(0,t.jsx)(n.li,{children:"Unit and integration tests"}),"\n",(0,t.jsx)(n.li,{children:"A generalized example of a validation workflow and/or notebook using California cropland datasets spanning multiple sites and crop types."}),"\n",(0,t.jsx)(n.li,{children:"Documentation"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Prerequisites:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Required: R (existing workflow and prototype is in R), familiarity with statistical methods for model validation"}),"\n",(0,t.jsx)(n.li,{children:"Helpful: Familiarity with existing benchmarking workflow systems"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Contact person:"})}),"\n",(0,t.jsx)(n.p,{children:"Chris Black (@infotroph)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Duration:"})}),"\n",(0,t.jsx)(n.p,{children:"Flexible to work as either a Medium (175hr) or Large (350 hr)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Difficulty:"})}),"\n",(0,t.jsx)(n.p,{children:"Medium"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"module",children:"3. Increase PEcAn modularity"}),"\n",(0,t.jsxs)(n.p,{children:["Existing PEcAn workflows rely heavily on reading a large ",(0,t.jsx)(n.code,{children:"settings"})," object and writing .RData files or other opaque artifacts to disk to pass state between steps. This behavior reduces transparency, testability, and user understanding. The high-level goal of this project is to make PEcAn\u2019s core functionality more modular and transparent, so that users can more easily build, maintain, and expand PEcAn workflows."]}),"\n",(0,t.jsx)(n.p,{children:"This project refactors a single, well-defined workflow so that functions return explicit R objects (e.g., data frames or lists) instead of relying on hidden on-disk side effects."}),"\n",(0,t.jsx)(n.p,{children:"To minimize disruption with existing workflows, the preferred approach would be:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"To begin by documenting existing functionality"}),"\n",(0,t.jsx)(n.li,{children:"Where needed, write tests for existing functionality"}),"\n",(0,t.jsx)(n.li,{children:"Document new functionality"}),"\n",(0,t.jsx)(n.li,{children:"Write tests for new functionality (TDD)"}),"\n",(0,t.jsx)(n.li,{children:"Refactoring of functions to return objects"}),"\n",(0,t.jsx)(n.li,{children:"Then refactor downstream functions use those objects"}),"\n",(0,t.jsx)(n.li,{children:"Only after that\u2019s working, stop writing out the files."}),"\n",(0,t.jsxs)(n.li,{children:["If time permits, analyze how PEcAn's high-level modules are using the ",(0,t.jsx)(n.code,{children:"settings"})," object and, where possible, refactor function inputs to only pass the required subset of variables or variable lists."]}),"\n",(0,t.jsx)(n.li,{children:"Along the way, it would also be beneficial to reassess which functions need to be exported, with the idea that fewer exported functions would make it easier for new users to see what PEcAn\u2019s core modules actually are, and better documenting the core functions and modules we expect users to need to learn/use"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Expected outcomes"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Refactored functions that return explicit R objects instead of writing .RData"}),"\n",(0,t.jsx)(n.li,{children:"Clear definition and doucmentation of object structures passed between steps"}),"\n",(0,t.jsx)(n.li,{children:"Backward-compatible wrappers where needed to avoid breaking existing workflows"}),"\n",(0,t.jsx)(n.li,{children:"Unit tests that no longer depend on on-disk state or output_dir"}),"\n",(0,t.jsx)(n.li,{children:"Documentation describing .RData deprecation, migration guidance, and examples"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Skills Required"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Required: R (existing workflow and prototype is in R) and R package development"}),"\n",(0,t.jsx)(n.li,{children:"Helpful: familiarity with code refactoring"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Contact person:"})}),"\n",(0,t.jsx)(n.p,{children:"Mike @Dietze"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Duration:"})}),"\n",(0,t.jsx)(n.p,{children:"Suitable for a Medium (175hr) or Large (350 hr) project."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Difficulty:"})}),"\n",(0,t.jsx)(n.p,{children:"Medium"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"couplertools",children:"4. Standardizing Model Couplers Across Models"}),"\n",(0,t.jsx)(n.p,{children:"PEcAn models frequently duplicate similar logic for writing configuration files, translating meteorological inputs, and handling model-specific I/O. This copy\u2013paste pattern increases maintenance cost and makes it harder to integrate new models consistently."}),"\n",(0,t.jsx)(n.p,{children:"This project identifies a small set of shared configuration and I/O patterns and refactors them into documented helper functions with well-defined interfaces. Possible examples include netCDF reading/writing, parsing standardized input files,  test fixtures, settings validation, and others. The approach should be demonstrated across a limited number of models coupler packages under active development."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Expected outcomes:"}),"\nA successful project will deliver an inventory of duplicated configuration and I/O patterns along with one or more of the following steps toward deduplication:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Shared helper functions with explicit inputs, outputs, and unit conventions"}),"\n",(0,t.jsx)(n.li,{children:"Refactored model code using standardized helpers"}),"\n",(0,t.jsx)(n.li,{children:"Unit tests ensuring consistent behavior across models"}),"\n",(0,t.jsx)(n.li,{children:"Updated developer documentation describing standard interfaces and recommended usage"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Prerequisites:"}),"\nRequired: Proficiency in R\nHelpful: experience with unit testing"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Contact person:"}),"\nChris Black, @infotroph"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Duration:"}),":\nMedium (175hr) or Large (350 hr) depending on number of deliverables"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Difficulty:"}),"\nMedium"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);